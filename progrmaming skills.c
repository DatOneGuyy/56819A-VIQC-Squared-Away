#pragma config(Sensor, port1,  color2,         sensorVexIQ_LED)
#pragma config(Sensor, port2,  color1,         sensorVexIQ_LED)
#pragma config(Sensor, port3,  gyro,           sensorVexIQ_Gyro)
#pragma config(Sensor, port4,  color3,         sensorVexIQ_LED)
#pragma config(Sensor, port11, color4,         sensorVexIQ_LED)
#pragma config(Sensor, port12, color5,         sensorVexIQ_LED)
#pragma config(Motor,  motor5,          arm,           tmotorVexIQ, PIDControl, encoder)
#pragma config(Motor,  motor6,          backarm,       tmotorVexIQ, PIDControl, encoder)
#pragma config(Motor,  motor7,          strafe,        tmotorVexIQ, PIDControl, encoder)
#pragma config(Motor,  motor8,          rightdrive,    tmotorVexIQ, PIDControl, driveRight, encoder)
#pragma config(Motor,  motor9,          leftdrive,     tmotorVexIQ, PIDControl, reversed, driveLeft, encoder)
#pragma config(Motor,  motor10,         spintake,      tmotorVexIQ, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

float e = 2.71828459045;
int k = 4000;
bool gear = true;
int lightMode = 0;

int dropDelay = 250;

bool sucking = false;
bool barfing = false;

int sign(int value) {
	return value == 0 ? 0 : abs(value) / value;
}

void setup() {
	setMotorSpeed(leftdrive, 0);
	setMotorSpeed(rightdrive, 0);
	setMotorSpeed(strafe, 0);
	setMotorSpeed(arm, 0);
	resetMotorEncoder(arm);
	resetMotorEncoder(strafe);
	resetMotorEncoder(rightdrive);
	resetMotorEncoder(leftdrive);
	resetMotorEncoder(backarm);
	setGyroSensitivity(gyro, gyroNormalSensitivity);
	resetGyro(gyro);
}

void driveReset() {
	setMotorSpeed(leftdrive, 0);
	setMotorSpeed(rightdrive, 0);
	setMotorSpeed(strafe, 0);
	resetMotorEncoder(rightdrive);
	resetMotorEncoder(leftdrive);
	resetMotorEncoder(strafe);
}

void forward(int ticks, int speed) {
	moveMotorTarget(leftdrive, ticks * sign(speed), speed);
	moveMotorTarget(rightdrive, ticks * sign(speed), speed);
	waitUntilMotorStop(leftdrive);
	setMotorSpeed(leftdrive, 0);
	setMotorSpeed(rightdrive, 0);
}

void turnLeft(int degrees, int speed) {
	setup();
	while (abs(degrees) > abs(getGyroDegrees(gyro))) {
		setMotorSpeed(leftdrive, -speed);
		setMotorSpeed(rightdrive, speed);
	}
	driveReset();
}

void turnRight(int degrees, int speed) {
	setup();
	while (abs(degrees) > abs(getGyroDegrees(gyro))) {
		setMotorSpeed(leftdrive, speed);
		setMotorSpeed(rightdrive, -speed);
	}
	driveReset();
}

//true = left, false = right
//ticks > 0 and speed > 0
void s(int ticks, int speed, bool dir) {
	/*
	driveReset();
	while (ticks > abs(getMotorEncoder(strafe))) {
		setMotorSpeed(strafe, speed * dir ? -1 : 1);
	}
	driveReset();
	*/
	resetGyro(gyro);
	moveMotorTarget(strafe, ticks * sign(speed * dir ? -1 : 1), speed * (dir ? -1 : 1));
	waitUntilMotorStop(strafe);
	driveReset();
}

void a(int ticks, int speed) {
	setMotorSpeed(arm, speed);
	sleep(ticks);
	setMotorSpeed(arm, 0);
	setup();
}

void togglesucking() {
	if (!sucking) {
		setMotorSpeed(spintake, 100);
	} else {
		setMotorSpeed(spintake, 0);
	}
}

void togglebarfing() {
	if (!barfing) {
		setMotorSpeed(spintake, -100);
		barfing = true;
	} else {
		setMotorSpeed(spintake, 0);
		barfing = false;
	}
}

void back(int speed, int ticks) {
	setMotorSpeed(backarm, speed);
	sleep(ticks);
	setMotorSpeed(backarm, 0);
}

void diagonal(int forwardSpeed, int strafeSpeed, int ticks) {
	setMotorSpeed(leftdrive, forwardSpeed);
	setMotorSpeed(rightdrive, forwardSpeed);
	setMotorSpeed(strafe, strafeSpeed);
	sleep(ticks);
	driveReset();
}

int mapFast(int value) {
	float A = 633.992;
	float C = -4.36118;
	float b = -5.4813;
	float c = 101.126;
	float k = -1.90005;
	float a = -0.0000200555;
	float n = 2.66124;
	float power = -a * pow(value - b, n);
	float denominator = k + C * pow(e, power);
	return value != 0 ? round((A / denominator + c) * (abs(value) / value)) : 0;
}

int mapSlow(int value) {
	float A = 380.95;
	float C = -4.36118;
	float b = -5.4813;
	float c = 60.6755;
	float k = -1.90005;
	float a = -0.0000200555;
	float n = 2.66124;
	float power = -a * pow(value - b, n);
	float denominator = k + C * pow(e, power);
	return value != 0 ? round((A / denominator + c) * (abs(value) / value)) : 0;
}

int t = 0;
int mode = 0;
int larm;

int sign(int value) {
	return value == 0 ? 0 : abs(value) / value;
}

bool checkIfZero() { //false if one is zero true if both are not zero
	return getJoystickValue(ChA) != 0 && getJoystickValue(ChD) != 0;
}

void updateTouchLED() {
	if (lightMode == 5) {
		lightMode = 0;
	} else {
		lightMode++;
	}
	switch (lightMode) {
		case 0:
			setTouchLEDColor(color1, colorRed);
			setTouchLEDColor(color2, colorRed);
			setTouchLEDColor(color3, colorRed);
			setTouchLEDColor(color4, colorRed);
			break;
		case 1:
			setTouchLEDColor(color1, colorOrange);
			setTouchLEDColor(color2, colorOrange);
			setTouchLEDColor(color3, colorOrange);
			setTouchLEDColor(color4, colorOrange);
			break;
		case 2:
			setTouchLEDColor(color1, colorYellow);
			setTouchLEDColor(color2, colorYellow);
			setTouchLEDColor(color3, colorYellow);
			setTouchLEDColor(color4, colorYellow);
			break;
		case 3:
			setTouchLEDColor(color1, colorGreen);
			setTouchLEDColor(color2, colorGreen);
			setTouchLEDColor(color3, colorGreen);
			setTouchLEDColor(color4, colorGreen);
			break;
		case 4:
			setTouchLEDColor(color1, colorBlue);
			setTouchLEDColor(color2, colorBlue);
			setTouchLEDColor(color3, colorBlue);
			setTouchLEDColor(color4, colorBlue);
			break;
		case 5:
			setTouchLEDColor(color1, colorViolet);
			setTouchLEDColor(color2, colorViolet);
			setTouchLEDColor(color3, colorViolet);
			setTouchLEDColor(color4, colorViolet);
			break;
		default:
			setTouchLEDColor(color1, colorRed);
			setTouchLEDColor(color2, colorRed);
			setTouchLEDColor(color3, colorRed);
			setTouchLEDColor(color4, colorRed);
			break;
	}
}

int leftspeed;
int rightspeed;

int released1 = 0;
int released2 = 0;

int taps = 0;

task main() {
	updateTouchLED();
	while (true) {
		if (getTouchLEDValue(color5) == 1 && taps == 0) {
			hogCPU();
			setup();
			taps = 1;
			//block 1
			forward(120, 40);
			s(700, 50, true);
			turnRight(24, 40);
			forward(440, 30);
			setMotorSpeed(spintake, -100);
			a(2500, 100);
			setMotorSpeed(spintake, 0);
			forward(240, -100);
			turnLeft(163, 30); //do not change
			s(200, 40, true);
			forward(250, 100);
			sleep(300);
			forward(30, -40);
			a(1500, -100);
			sleep(500);
			forward(80, -70);

			
			//block 2
			turnLeft(40, 40);
			forward(200, 50);
			sleep(200);
			forward(200, -50);
			sleep(400);
			turnLeft(45, 40);
			a(700, -100);
			sleep(200);
			forward(600, -40);
			sleep(400);
			setMotorSpeed(backarm, 100);
			sleep(600);
			turnRight(82, 40);
			forward(880, -100);
			setMotorSpeed(backarm, -100);
			sleep(700);
			setMotorSpeed(backarm, 0);
			sleep(300);
			forward(200, 80);
			
			/*
			//block 3
			forward(450, 60);
			s(630, 50, false);
			setMotorSpeed(backarm, -100);
			sleep(400);
			setMotorSpeed(backarm, 0);
			forward(300, -50);
			setMotorSpeed(backarm, 100);
			sleep(900);
			forward(400, -100);
			setMotorSpeed(backarm, 30);
			forward(1000, 40);
			setMotorSpeed(spintake, -100);
			a(1900, 100);
			setMotorSpeed(spintake, 0);
			forward(380, -60);
			sleep(200);
			s(1570, 80, true);
			if (getGyroDegrees(gyro) > 0) {
				turnRight(abs(getGyroDegrees(gyro)), abs(getGyroDegrees(gyro)) * 2);
			} else if (getGyroDegrees(gyro) < 0) {
				turnLeft(abs(getGyroDegrees(gyro)), abs(getGyroDegrees(gyro)) * 2);
			}
			forward(190, 40);
			a(1500, -100);
			forward(300, -40);
			turnRight(150, 40);
			forward(550, -60);
			setMotorSpeed(backarm, -100);
			sleep(800);
			setMotorSpeed(backarm, 0);
			*/
			
			
			/*
			//block 5
			forward(530, 60);
			s(740, 50, true);
			forward(300, 40);
			setMotorSpeed(spintake, -100);
			a(1900, 100);
			setMotorSpeed(spintake, 0);
			forward(450, -60);
			sleep(200);	
			turnRight(70, 40);
			forward(2000, 100);
			turnRight(40, 40);
			a(1600, -100);
			forward(900, 100);
			sleep(50);
			forward(500, -100);
			*/
		}
		if (getTouchLEDValue(color5) == 1 && taps == 1) {
			taps = 2;
			s(740, 70, false);
			turnLeft(27, 30);
			forward(630, 30);
			setMotorSpeed(spintake, -100);
			a(2000, 100);
			setMotorSpeed(spintake, 0);
			s(890, 90, false);
			forward(270, 50);
			a(1500, -100);
			forward(200, -70);
		}
		if (getTouchLEDValue(color5) == 1 && taps == 2) {
			forward(530, 60);
			s(740, 50, true);
			a(300, -100);
			forward(300, 40);
			setMotorSpeed(spintake, -100);
			a(1000, 100);
			setMotorSpeed(spintake, 0);
			forward(450, -60);
			sleep(200);	
			turnRight(70, 40);
			forward(2000, 100);
			turnRight(20, 40);
			a(900, -100);
			forward(900, 100);
			sleep(50);
			forward(200, -100);
		}
		displayCenteredTextLine(1, "%d", getGyroDegrees(gyro));
		if (getJoystickValue(BtnLUp) == 1 && getJoystickValue(BtnLDown) == 0) {
			setMotorSpeed(arm, 100);
		} else if (getJoystickValue(BtnLDown) == 1 && getJoystickValue(BtnLUp) == 0) {
			setMotorSpeed(arm, -100);
		} else {
			setMotorSpeed(arm, 0);
		}
		if (getJoystickValue(BtnRDown) == 1 && getJoystickValue(BtnRUp) == 0) {
			setMotorSpeed(backarm, -100);
		} else if (getJoystickValue(BtnRUp) == 1 && getJoystickValue(BtnRDown) == 0) {
			setMotorSpeed(backarm, 100);
		} else {
			setMotorSpeed(backarm, 0);
		}
	}
}
